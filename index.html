<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amoro - Psytrance Visualization</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <canvas id="fractalCanvas"></canvas>
    
    <script>
// Psytrance-Inspired Techno Visualization
// Vibrant neon colors, sacred geometry, dodecahedron outlines, Rorschach, infinite fractals, slow fades, sudden glitches

const canvas = document.getElementById('fractalCanvas');
const ctx = canvas.getContext('2d');

let width, height;
let mouseX = 0.5;
let mouseY = 0.5;
let time = 0;
let currentPattern = 0;
let interacting = false;
let lastMoveTime = 0;
let isTouch = false;
let fadeOpacity = 0.03; // Start low, increase for disappear

// Psytrance colors: neon pinks, greens, blues, yellows, purples
const psyColors = ['#FF00FF', '#00FF00', '#00FFFF', '#FFFF00', '#FF00FF'];

// Constants
const TEMPO = 128 / 60;
const PULSE_FREQ = TEMPO * 8;
const FLASH_THRESHOLD = 0.9;
const GLITCH_FREQ = TEMPO * 4;
const STOP_THRESHOLD = 0.5;
const COLOR_SWAP_SPEED = 0.05; // Slow color swap

// Resize
function resizeCanvas() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}

resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Mouse/touch
document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX / width;
    mouseY = e.clientY / height;
    lastMoveTime = time;
    if (!interacting) interacting = true;
    isTouch = false;
});

document.addEventListener('touchmove', (e) => {
    if (e.touches.length > 0) {
        mouseX = e.touches[0].clientX / width;
        mouseY = e.touches[0].clientY / height;
        lastMoveTime = time;
        if (!interacting) interacting = true;
        isTouch = true;
    }
});

document.addEventListener('touchend', () => {
    currentPattern = (currentPattern + 1) % 8; // More patterns
    interacting = false;
});

// Pulse
function pulseScale() {
    return 1 + 0.3 * Math.abs(Math.sin(time * PULSE_FREQ * Math.PI * 2));
}

// Get swapping color
function getPsyColor(offset = 0) {
    const index = Math.floor((time * COLOR_SWAP_SPEED + offset) % psyColors.length);
    return psyColors[index];
}

// Data stream with psy colors
function drawDataStream() {
    const density = 100 + mouseX * 100;
    const speed = 10 + mouseY * 20;
    
    for (let i = 0; i < density; i++) {
        const x = Math.random() * width;
        const y = (Math.random() * height + time * speed) % height;
        const binary = (Math.random() > 0.5 ? '1' : '0').repeat(10 + Math.floor(Math.random() * 20));
        
        ctx.font = `${15 + pulseScale() * 10}px monospace`;
        ctx.fillStyle = getPsyColor(i / density);
        ctx.fillText(binary, x, y);
    }
}

// Data path with psy
function drawDataPath(centerX, centerY, segments, depth, rotation) {
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(rotation + Math.sin(time * TEMPO) * 0.3);
    
    for (let i = 0; i < depth; i++) {
        const length = 70 + i * 30 * pulseScale();
        const angleStep = Math.PI * 2 / segments;
        
        for (let j = 0; j < segments; j++) {
            const angle = j * angleStep + Math.cos(time + i) * 0.15;
            const endX = Math.cos(angle) * length;
            const endY = Math.sin(angle) * length;
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = getPsyColor(j / segments);
            ctx.lineWidth = 2 + pulseScale() * 2;
            ctx.stroke();
        }
    }
    
    ctx.restore();
}

// Julia with psy
function drawDataField() {
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    
    const maxIterations = 60;
    const zoom = 1.3 + mouseX * 0.6 + 0.3 * Math.sin(time * PULSE_FREQ);
    const cX = -0.75 + mouseX * 0.25;
    const cY = 0.2 + mouseY * 0.15;
    
    for (let px = 0; px < width; px += 2) {
        for (let py = 0; py < height; py += 2) {
            let x = (px - width / 2) / (0.5 * zoom * width);
            let y = (py - height / 2) / (0.5 * zoom * height);
            
            let iteration = 0;
            while (x * x + y * y <= 4 && iteration < maxIterations) {
                const xTemp = x * x - y * y + cX;
                y = 2 * x * y + cY;
                x = xTemp;
                iteration++;
            }
            
            if (iteration < maxIterations) {
                const hue = (iteration / maxIterations * 360 + time * 50) % 360;
                const rgb = hslToRgb(hue / 360, 1, 0.5); // Vibrant
                for (let dx = 0; dx < 2 && px + dx < width; dx++) {
                    for (let dy = 0; dy < 2 && py + dy < height; dy++) {
                        const index = ((py + dy) * width + (px + dx)) * 4;
                        data[index] = rgb[0];
                        data[index + 1] = rgb[1];
                        data[index + 2] = rgb[2];
                        data[index + 3] = 255;
                    }
                }
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
}

// HSL to RGB for psy colors
function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

// Binary triangle with psy
function drawBinaryTriangle(x, y, size, depth) {
    if (depth === 0 || size < 10) {
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + size, y);
        ctx.lineTo(x + size / 2, y - size * Math.sin(Math.PI / 3) * pulseScale());
        ctx.closePath();
        ctx.fillStyle = getPsyColor();
        ctx.fill();
        ctx.strokeStyle = getPsyColor(0.5);
        ctx.lineWidth = pulseScale() * 1.5;
        ctx.stroke();
        return;
    }
    
    const halfSize = size / 2;
    const height = size * Math.sin(Math.PI / 3);
    
    drawBinaryTriangle(x, y, halfSize, depth - 1);
    drawBinaryTriangle(x + halfSize, y, halfSize, depth - 1);
    drawBinaryTriangle(x + halfSize / 2, y - height / 2, halfSize, depth - 1);
}

// Spiral with infinite feel
function drawSpiralPattern() {
    ctx.lineCap = 'round';
    const size = Math.min(width, height) * 0.3;
    const maxLevel = 10 + Math.floor(mouseX * 5); // Deeper for infinite
    const scale = 0.8 + mouseY * 0.1;
    const spread = 0.2 + mouseX * 0.2 + Math.sin(time) * 0.1;
    const lineWidth = 6 * pulseScale();
    const sides = Math.floor(3 + mouseY * 4);

    function drawBranch(level) {
        if (level > maxLevel) return;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(size, 0);
        ctx.stroke();

        ctx.save();
        ctx.translate(size * 0.1, 0);
        ctx.scale(scale, scale);
        ctx.rotate(spread);
        drawBranch(level + 1);
        ctx.restore();

        ctx.save();
        ctx.translate(size * 0.5, 0);
        ctx.scale(scale, scale);
        ctx.rotate(spread * 1.5);
        drawBranch(level + 1);
        ctx.restore();

        ctx.save();
        ctx.translate(size * 0.6, 0);
        ctx.scale(scale * 0.3, scale * 0.3);
        ctx.rotate(spread * 0.5);
        drawBranch(level + 1);
        ctx.restore();
    }

    ctx.strokeStyle = getPsyColor();
    ctx.lineWidth = lineWidth;
    ctx.save();
    ctx.translate(width/2, height/2);
    for (let i = 0; i < sides; i++){
        ctx.rotate((Math.PI * 2)/sides + time * 0.1);
        drawBranch(0);
    }
    ctx.restore();
}

// Mandelbrot with psy colors
function drawMandelbrot() {
    const imageData = ctx.createImageData(width, height);
    const data = imageData.data;
    
    const maxIterations = 100; // Deeper for infinite
    const zoom = 1 / (1 + mouseX * 10 + Math.pow(time % 10, 2)); // Zoom in for infinite
    const offsetX = -0.5 + mouseX * 0.5;
    const offsetY = mouseY * 0.5;
    
    for (let px = 0; px < width; px += 2) {
        for (let py = 0; py < height; py += 2) {
            let x0 = (px / width * 3.5 - 2.5) * zoom + offsetX;
            let y0 = (py / height * 2 - 1) * zoom + offsetY;
            let x = 0;
            let y = 0;
            let iteration = 0;
            while (x * x + y * y <= 4 && iteration < maxIterations) {
                const xTemp = x * x - y * y + x0;
                y = 2 * x * y + y0;
                x = xTemp;
                iteration++;
            }
            
            if (iteration < maxIterations) {
                const hue = (iteration / maxIterations * 360 + time * 20) % 360;
                const rgb = hslToRgb(hue / 360, 1, 0.5);
                for (let dx = 0; dx < 2 && px + dx < width; dx++) {
                    for (let dy = 0; dy < 2 && py + dy < height; dy++) {
                        const index = ((py + dy) * width + (px + dx)) * 4;
                        data[index] = rgb[0];
                        data[index + 1] = rgb[1];
                        data[index + 2] = rgb[2];
                        data[index + 3] = 255;
                    }
                }
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
}

// Dodecahedron outline (2D projection)
function drawDodecahedron() {
    const scale = height * 0.2 * pulseScale();
    const rotation = time * 0.2;
    const phi = (1 + Math.sqrt(5)) / 2;
    const vertices = [
        [1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1],
        [-1, 1, 1], [-1, 1, -1], [-1, -1, 1], [-1, -1, -1],
        [0, phi, 1/phi], [0, phi, -1/phi], [0, -phi, 1/phi], [0, -phi, -1/phi],
        [1/phi, 0, phi], [1/phi, 0, -phi], [-1/phi, 0, phi], [-1/phi, 0, -phi],
        [phi, 1/phi, 0], [phi, -1/phi, 0], [-phi, 1/phi, 0], [-phi, -1/phi, 0]
    ];

    const edges = [
        [0,2],[0,4],[0,12],[1,3],[1,5],[1,13],[2,6],[2,14],[3,7],[3,15],
        [4,8],[4,16],[5,9],[5,17],[6,10],[6,18],[7,11],[7,19],[8,9],
        [8,16],[9,17],[10,11],[10,18],[11,19],[12,13],[12,16],[13,17],
        [14,15],[14,18],[15,19]
    ];

    function project(v) {
        const rx = v[0] * Math.cos(rotation) - v[2] * Math.sin(rotation);
        const rz = v[0] * Math.sin(rotation) + v[2] * Math.cos(rotation);
        const ry = v[1] * Math.cos(rotation) - rz * Math.sin(rotation);
        rz = v[1] * Math.sin(rotation) + rz * Math.cos(rotation);
        return [rx * scale + width / 2, ry * scale + height / 2];
    }

    ctx.strokeStyle = getPsyColor();
    ctx.lineWidth = 2;
    edges.forEach(([a, b]) => {
        const pa = project(vertices[a]);
        const pb = project(vertices[b]);
        ctx.beginPath();
        ctx.moveTo(pa[0], pa[1]);
        ctx.lineTo(pb[0], pb[1]);
        ctx.stroke();
    });
}

// Rorschach symmetrical pattern
function drawRorschach() {
    const blobCount = 20 + Math.floor(mouseY * 20);
    const symmetryAxis = width / 2;
    
    for (let i = 0; i < blobCount; i++) {
        const x = symmetryAxis + (Math.random() - 0.5) * width * 0.3;
        const y = height / 2 + (Math.random() - 0.5) * height * 0.4;
        const radius = 20 + Math.random() * 50 * pulseScale();
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = getPsyColor(i / blobCount);
        ctx.fill();
        
        // Mirror
        ctx.beginPath();
        ctx.arc(width - x, y, radius, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Pixel sort
function pixelSortRow(data, y, startX, endX) {
    const pixels = [];
    for (let x = startX; x < endX; x++) {
        const index = (y * width + x) * 4;
        const brightness = (data[index] + data[index + 1] + data[index + 2]) / 3;
        pixels.push({r: data[index], g: data[index+1], b: data[index+2], a: data[index+3], brightness});
    }
    pixels.sort((a, b) => a.brightness - b.brightness);
    for (let x = startX; x < endX; x++) {
        const index = (y * width + x) * 4;
        const p = pixels[x - startX];
        data[index] = p.r;
        data[index + 1] = p.g;
        data[index + 2] = p.b;
        data[index + 3] = p.a;
    }
}

// Glitch with datamosh
function applyGlitch(sudden = false) {
    const imageData = ctx.getImageData(0, 0, width, height);
    const data = imageData.data;
    
    const numSlices = sudden ? 10 : 3 + Math.floor(Math.random() * 3);
    for (let s = 0; s < numSlices; s++) {
        const sliceY = Math.floor(Math.random() * height);
        const sliceHeight = Math.floor(10 + Math.random() * 20);
        const shift = Math.floor(-30 + Math.random() * 60);
        
        for (let y = sliceY; y < sliceY + sliceHeight && y < height; y++) {
            for (let x = 0; x < width; x++) {
                const origIndex = (y * width + x) * 4;
                const newX = (x + shift + width) % width;
                const newIndex = (y * width + newX) * 4;
                
                data[newIndex] = data[origIndex];
                data[newIndex + 1] = data[origIndex + 1];
                data[newIndex + 2] = data[origIndex + 2];
                data[newIndex + 3] = data[origIndex + 3];
            }
        }
    }
    
    const noiseDensity = sudden ? 0.02 : 0.005;
    for (let i = 0; i < data.length; i += 4) {
        if (Math.random() < noiseDensity) {
            const noise = Math.floor(-30 + Math.random() * 60);
            data[i] = Math.max(0, Math.min(255, data[i] + noise));
            data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
            data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
        }
    }
    
    const numSortRows = sudden ? 15 : 5 + Math.floor(Math.random() * 5);
    for (let s = 0; s < numSortRows; s++) {
        const y = Math.floor(Math.random() * height);
        const segmentLength = Math.floor(50 + Math.random() * 200);
        const startX = Math.floor(Math.random() * (width - segmentLength));
        pixelSortRow(data, y, startX, startX + segmentLength);
    }
    
    const numMosh = sudden ? 10 : 5;
    for (let s = 0; s < numMosh; s++) {
        const x = Math.floor(Math.random() * width);
        const y = Math.floor(Math.random() * height);
        const w = Math.floor(50 + Math.random() * 200);
        const h = Math.floor(50 + Math.random() * 200);
        const dx = Math.floor(-10 + Math.random() * 20);
        const dy = Math.floor(-10 + Math.random() * 20);
        if (x + w > width || y + h > height) continue;
        const moshData = ctx.getImageData(x, y, w, h);
        ctx.putImageData(moshData, x + dx, y + dy);
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // Scan lines
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.lineWidth = 1;
    for (let y = 0; y < height; y += 2) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
    }
}

// Animation
function animate() {
    time += 0.02;
    
    // Slow background disappear: increase fade
    fadeOpacity = Math.min(0.1, fadeOpacity + 0.0001);
    ctx.fillStyle = `rgba(0, 0, 0, ${fadeOpacity})`;
    ctx.fillRect(0, 0, width, height);
    
    // Flash
    if (Math.sin(time * PULSE_FREQ * Math.PI * 2) > FLASH_THRESHOLD) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(0, 0, width, height);
    }
    
    switch (currentPattern) {
        case 0:
            drawDataStream();
            break;
        case 1:
            drawDataField();
            break;
        case 2:
            const count = 3 + Math.floor(mouseY * 3);
            for (let i = 0; i < count; i++) {
                const x = width / 2 + Math.sin(time * TEMPO + i) * width * 0.2;
                const y = height / 2 + Math.cos(time * TEMPO + i) * height * 0.2;
                drawDataPath(x, y, 16 + Math.floor(mouseX * 12), 8, time * TEMPO / 2);
            }
            break;
        case 3:
            const size = height * 0.45 + mouseY * height * 0.25;
            const offsetX = width / 2 - size / 2;
            const offsetY = height / 2 + size * 0.3;
            drawBinaryTriangle(offsetX, offsetY, size, 6);
            
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.rotate(time * TEMPO / 3);
            ctx.translate(-width / 2, -height / 2);
            drawBinaryTriangle(offsetX, offsetY, size * 0.7, 5);
            ctx.restore();
            break;
        case 4:
            drawSpiralPattern();
            break;
        case 5:
            drawMandelbrot();
            break;
        case 6:
            drawDodecahedron();
            break;
        case 7:
            drawRorschach();
            break;
    }
    
    // Glitch, sudden on random
    if (Math.sin(time * GLITCH_FREQ * Math.PI * 2) > 0.95 || Math.random() < 0.01) { // Sudden changes
        applyGlitch(Math.random() < 0.5);
    }
    
    // Check stop
    if (interacting && time - lastMoveTime > STOP_THRESHOLD) {
        currentPattern = (currentPattern + 1) % 8;
        interacting = false;
    }
    
    requestAnimationFrame(animate);
}

animate();
    </script>
</body>
</html>
